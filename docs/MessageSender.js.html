<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: MessageSender.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: MessageSender.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Created by macdja38 on 2016-10-01.
 */
"use strict";

class MessageSender {
  /**
   * Webhook sender which can be used to bulk together messages, designed for use with Webhooks but sends text as a fallback
   * @constructor
   * @param {Object} e
   * @param {Client} e.client
   */
  constructor(e) {
    this._client = e.client;
    this._queuedMessages = {};

    //noinspection JSUnusedGlobalSymbols
    this.hookSender = setInterval(this.emptyQueue.bind(this), 2500);
  }

  /**
   * empties the current queue
   */
  emptyQueue() {
    for (let channelId in this._queuedMessages) {
      if (!this._queuedMessages.hasOwnProperty(channelId)) continue;
      let queue = this._queuedMessages[channelId];
      let first = queue.slice(0, 1)[0];
      let options = queue.slice(1).reduce((prev, cur) => {
        prev.options.attachments = prev.options.attachments.concat(...cur.options.attachments);
        return prev;
      }, first);
      this._getWebhook(first.channel).then(webhook => {
        console.log(options.options);
        this._client.executeSlackWebhook(webhook.id, webhook.token, options.options);
      }).catch(() => {
        let texts;
        if (queue.length > 1) {
          texts = queue.slice(1).reduce((prev, cur) => `${prev.text}\n${cur.text}`, first).match(/^.{1,1999}/g);
        } else {
          texts = first.text.match(/^.{1,1999}/g);
        }
        texts.forEach((string) => {
          first.channel.createMessage(string);
        });
      })
    }
    this._queuedMessages = {};
  }

  /**
   * Adds a message to the message sending queue possibly joining it to other messages
   * @param {Channel} channel in which to send the message
   * @param {string} text to send with the message
   * @param {Object} options including title and other content
   */
  sendQueuedMessage(channel, text, options) {
    if (!this._queuedMessages.hasOwnProperty(channel.id || channel)) {
      this._queuedMessages[channel.id || channel] = [];
    }
    this._queuedMessages[channel.id || channel].push({channel, text, options});
  }

  /**
   * Sends a message in the channel through webhooks
   * @param {GuildChannel | String} channel to send the message in
   * @param {string} text text to send in that channel if sending a webhook is not possible
   * @param {Object} options
   */
  sendMessage(channel, text, options) {
    this._getWebhook(channel).then(webhook => {
      return this._client.sendWebhookMessage(webhook, text, options);
    }).catch(() => {
      this._client.createMessage(channel.id, text).catch(error => console.error(error));
    });

  }

  /**
   * Fetches a webhook for a channel
   * @param {GuildChannel | string} channel
   * @returns {Promise}
   * @private
   */
  async _getWebhook(channel) {
    if (/https:\/\/(?:ptb.|canary\.)?discordapp\.com\/api\/webhooks\/(\d+)\/(.+)/.test(channel)) {
      let matches = channel.match(/https:\/\/(?:ptb.|canary\.)?discordapp\.com\/api\/webhooks\/(\d+)\/(.+)/i);
      return {id: matches[1], token: matches[2]};
    }
    if (!channel.permissionsOf(this._client.user.id).has("manageWebhooks")) {
      throw "Insufficient permissions to create a webhook";
    }
    let existingHooks = await channel.getWebhooks();
    if (existingHooks &amp;&amp; existingHooks.length > 0) {
      return existingHooks[0];
    }
    return channel.createWebhook({name: this._client.user.username, avatar: this._client.user.avatar});
  }
}

module.exports = MessageSender;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Analytics.html">Analytics</a></li><li><a href="Command.html">Command</a></li><li><a href="Config.html">Config</a></li><li><a href="ConfigDB.html">ConfigDB</a></li><li><a href="Feeds.html">Feeds</a></li><li><a href="MessageSender.html">MessageSender</a></li><li><a href="ParseState.html">ParseState</a></li><li><a href="Permissions.html">Permissions</a></li><li><a href="Player.html">Player</a></li><li><a href="Queue.html">Queue</a></li><li><a href="SlowSender.html">SlowSender</a></li><li><a href="StandardDB.html">StandardDB</a></li><li><a href="Track.html">Track</a></li><li><a href="Utils.html">Utils</a></li><li><a href="WarframeData.html">WarframeData</a></li><li><a href="WorldState.html">WorldState</a></li><li><a href="worldState_prototype.html">prototype</a></li><li><a href="YoutubeTrack.html">YoutubeTrack</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addStar">addStar</a></li><li><a href="global.html#command">command</a></li><li><a href="global.html#DefaultOptions">DefaultOptions</a></li><li><a href="global.html#getOrderedGroups">getOrderedGroups</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#utils">utils</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Feb 28 2017 02:14:12 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
