<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: youtube-track.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: youtube-track.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Created by meew0 on 2015-011-27.
 */
"use strict";

let youtubeDl = require('youtube-dl');
let ytdl = require('ytdl-core');
let Track = require('./track.js');


// formats in order of preference when streaming them
// starting numbers are itag values for youtube https://en.wikipedia.org/wiki/YouTube#Quality_and_formats
let idealFormatIds = ["249", "250", "251", "171", "140", "141", "127", "128", "82", "83", "100", "84", "85", "5", "18", "43", "22", "36", "17", "http_mp3_128_url"];

class YoutubeTrack extends Track {
  /**
   * Youtube specific track
   * @param args passed to track this extends
   */
  constructor(...args) {
    super(...args);
  }

  /**
   * Get's a streamable URL from a track
   * @returns {*}
   */
  getURL() {
    let streamableSource = {};
    let formats = this.containedVideo.formats;
    streamableSource.sourceURL = this.containedVideo.webpage_url || this.containedVideo.loaderUrl;
    // try and just use itag values
    let formatMap = formats.map(f => getFormatId(f));
    for (let itag of idealFormatIds) {
      if (formatMap.indexOf(itag) > -1) {
        let format = formats[formatMap.indexOf(itag)];
        streamableSource.encoding = getEncoding(format);
        streamableSource.container = getContainer(format);
        streamableSource.url = format.url;
        return streamableSource;
      }
    }

    let opusItems = this.containedVideo.formats
      .filter(f => isEncodedAs(f, "opus"));
    let webMOpusItems = opusItems.filter(f => isContainer(f, "webm"));
    if (webMOpusItems.length > 0) {
      streamableSource.encoding = "opus";
      streamableSource.container = "webm";
      let sortedwebMOpusItems = webMOpusItems.sort((a, b) => (b.abr || b.audioBitrate) - (a.abr || a.audioBitrate));
      streamableSource.url = sortedwebMOpusItems[0].url;
      if (this.raven) {
        process.nextTick(() => {
          let formats = toObj(this.containedVideo.formats);
          formats.chosen = streamableSource;
          this.raven.captureException("Could not determine format using itag values, found a webm/opus though", {
            extra: formats,
            level: "warning"
          });
        });
      }
      return streamableSource;
    }

    // let oggItems = opusItems.filter(f => isContainer(f, "ogg"));

    // second round, capture anything with a bitrate and no resolution
    formats = this.containedVideo.formats
      .sort((a, b) => b.abr - a.abr);
    if (formats.length > 0) {
      let format = (formats.find(f => (f.abr || f.audioBitrate) > 0 &amp;&amp; !f.resolution) || formats.find(f => (f.abr || f.audioBitrate) > 0));
      if (format) {
        streamableSource.url = format.url;
        streamableSource.container = getContainer(format);
        streamableSource.encoding = getEncoding(format);
        if (this.raven) {
          process.nextTick(() => {
            let formats = toObj(this.containedVideo.formats);
            formats.chosen = streamableSource;
            this.raven.captureException("Could not find a webm/opus to queue", {
                extra: formats,
                level: "warning"
              });
          });
        }
        return streamableSource;
      }


      // 3rd round, extract mp3's and return those.
      format = formats.find(f => isContainer(f, "mp3"));
      if (format) {
        streamableSource.url = format.url;
        streamableSource.container = getContainer(format);
        streamableSource.encoding = getEncoding(format);
        if (this.raven) {
          process.nextTick(() => {
            let formats = toObj(this.containedVideo.formats);
            formats.chosen = streamableSource;
            this.raven.captureException("Could not find something with a bitrate and no reduction, defaulting to mp3", {
              extra: formats,
              level: "warning"
            });
          });
        }
        return streamableSource;
      }

      // 4rd round, extract mp4's and return those.
      format = formats.find(f => isContainer(f, "mp4"));
      if (format) {
        streamableSource.url = format.url;
        streamableSource.container = getContainer(format);
        streamableSource.encoding = getEncoding(format);
        if (this.raven) {
          process.nextTick(() => {
            let formats = toObj(this.containedVideo.formats);
            formats.chosen = streamableSource;
            this.raven.captureException("Could not find something with a bitrate and no reduction, defaulting to mp3", {
              extra: formats,
              level: "warning"
            });
          });
        }
        return streamableSource;
      }
    }
    if (this.raven) {
      let extra = toObj(this.containedVideo.formats);
      extra.source = streamableSource.sourceURL;
      this.raven.captureException("Could not find a format to queue", {
        extra,
        level: "error"
      });
    }
    return null;

    // console.log("Formats found");
    // console.log(this.containedVideo.formats);
    // return (this.containedVideo.formats.find(f => f.format_id === "http_mp3_128_url") ||
    // this.containedVideo.formats.find(f => f.format_id === "fallback") || this.containedVideo.formats[0]).url;
  }

  getStream() {
    let options = {
      filter: (format) => format.container === 'mp4',
      quality: ['140', '141', '139', 'lowest'],
      audioonly: true
    };

    return ytdl.downloadFromInfo(this.containedVideo, options);
  }

  static getInfoFromVid(...args) {
    if (args[0].indexOf("youtu") > -1) {
      return fetchWithYtdl(...args).catch(() => fetchWithYoutubeDl(...args));
    } else {
      return fetchWithYoutubeDl(...args);
    }
  }
}


function fetchWithYtdl(vid, m, user, time, raven) {
  return new Promise((resolve, reject)=> {
    ytdl.getInfo(vid, [], (err, info) => {
      if (err) {
        reject(err);
      } else {
        let video = new YoutubeTrack(info.url, info, user, time, raven);
        video.userId = m.author.id;
        video.containedVideo = info;
        resolve(video);
      }
    })
  });
}

function fetchWithYoutubeDl(vid, m, user, time, raven) {
  return new Promise((resolve, reject)=> {
    youtubeDl.getInfo(vid, [], {maxBuffer: 1000 * 1024}, (err, info) => {
      if (err) {
        reject(err);
      }
      else {
        let video = new YoutubeTrack(info.url, info, user, time, raven);
        video.userId = m.author.id;
        video.containedVideo = info;
        resolve(video);
      }
    });
  })
}

/*YoutubeTrack.prototype.getURL = function () {
 console.log(this.containedVideo.formats);
 let formats = this.containedVideo.formats
 .filter(f => f.container === "webm")
 .sort((a, b) => b.audioBitrate - a.audioBitrate);

 return (formats.find(f => f.audioBitrate > 0 &amp;&amp; !f.bitrate) || formats.find(f => f.audioBitrate > 0)).url;
 };*/

function getEncoding(info) {
  return info.encoding || info.audioEncoding || info.acodec;
}

function getContainer(info) {
  return info.ext || info.container;
}

function getFormatId(info) {
  return info.itag || info.format_id;
}

function isEncodedAs(info, encoding) {
  return getEncoding(info) === encoding;
}

function isContainer(info, container) {
  return getContainer(info) === container;
}

function toObj(arr) {
  return arr.reduce(function (o, v, i) {
    o[i] = v;
    return o;
  }, {});
}

module.exports = YoutubeTrack;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Analytics.html">Analytics</a></li><li><a href="Command.html">Command</a></li><li><a href="Config.html">Config</a></li><li><a href="ConfigDB.html">ConfigDB</a></li><li><a href="Feeds.html">Feeds</a></li><li><a href="MessageSender.html">MessageSender</a></li><li><a href="ParseState.html">ParseState</a></li><li><a href="Permissions.html">Permissions</a></li><li><a href="Player.html">Player</a></li><li><a href="Queue.html">Queue</a></li><li><a href="SlowSender.html">SlowSender</a></li><li><a href="StandardDB.html">StandardDB</a></li><li><a href="Track.html">Track</a></li><li><a href="Utils.html">Utils</a></li><li><a href="WarframeData.html">WarframeData</a></li><li><a href="WorldState.html">WorldState</a></li><li><a href="worldState_prototype.html">prototype</a></li><li><a href="YoutubeTrack.html">YoutubeTrack</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addStar">addStar</a></li><li><a href="global.html#command">command</a></li><li><a href="global.html#DefaultOptions">DefaultOptions</a></li><li><a href="global.html#getOrderedGroups">getOrderedGroups</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#utils">utils</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Feb 28 2017 02:14:12 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
